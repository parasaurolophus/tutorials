#lang racket

;; Copyright Kirk Rader 2024

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Demonstrate basic use cases of call/cc and dynamic-wind
;;
;; Together with tail-call optimization and lexical closures,
;; first-class continuations created by calling the built-in call/cc
;; function are a core building block of CPS (Continuation Passing
;; Style). But they can be used to good effect in a variety of
;; contexts, including creating application specific, ad hoc
;; flow-of-control. The built-in dynamic-wind procedure is Scheme's
;; equivalent of Common Lisp's unwind-protect, Ruby's ensure and Go's
;; defer keywords etc. But note that Scheme's version provides
;; protection both for stack unwinding and stack rewinding since
;; first-class continuations allow previously exited execution
;; contexts to be re-entered. No, really. See the allow-resume and
;; test-resume examples, below.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Return from the middle of a procedure's body using call/cc.
;;
;; This shows how continuations can be used to implement the "return
;; statement" and similar non-sequential flow-of-control constructs
;; from many other languages.
(define (return-early x)
  (call/cc
   (lambda (return)
     (printf "invoking return with ~a\n" x)
     (return x)
     (printf "you will never see this\n"))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Return from the middle of a procedure's body using call/cc and
;; dynamic-wind to demonstrate stack unwinding protection.
;;
;; Identical to return-early example, but wraps that procedure's body
;; in dynamic-wind. The additional logging to stdout demonstrates how
;; to include stack unwinding and rewinding protection, where
;; necessary.
(define (return-early-with-protection x)

  (call/cc
   (lambda (return)

     (dynamic-wind

       (lambda ()
         (printf "entering protected extent\n"))

       (lambda ()
         (printf "\tcalling return with ~a as parameter\n" x)
         (return x)
         (printf "\tyou will never see this\n"))

       (lambda ()
         (printf "exiting protected extent\n"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Return a continuation from the middle of a body's procedure,
;; allowing its execution to be resumed.
;;
;; This builds on return-early-with-protection but shows how
;; continuations can be used not only to transfer control and data out
;; of a procedure but also back into it at a later time. The extra
;; logging generated by dynamic-wind surrounding the the nested
;; continuation passing shows why dynamic-wind needs both "before" and
;; "after" guards, not just the "after" guards represented byt the
;; finally, ensure, defer etc. mechnanisms of most languages.
(define (allow-resume x)

  (call/cc
   (lambda (return)

     (dynamic-wind

       (lambda ()
         (printf "\tentering protected extent\n"))

       (lambda ()
         (let ((y (call/cc (lambda (resume)
                             (printf "\t\treturning an inner continuation\n")
                             (return resume)))))
           (set! x (+ x y))
           (printf "\t\tresumed continuation received ~a, returning ~a\n" y x)
           x))

       (lambda ()
         (printf "\texiting protected extent\n"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Demonstrate that usage of allow-resume ends up looking like an
;; elaborate loop.
;;
;; The invocation of allow-resume returns twice, binding r to a
;; different value each time. First r is bound to allow-resume's inner
;; continuation and then to the final result after that continuation
;; is invoked and the previously interrupted computation is allowed to
;; complete normally. Note that the final result combines the value of
;; x originally passed to allow-resume and the value passed to the
;; inner continuation. This shows that both control and data can flow
;; in both directions using continuations. The extra logging performed
;; using dynamic-wind further shows how stack unwinding and rewinding
;; protection can be added where necessary.
(define (test-resume x)

  (printf "calling allow-resume with ~a\n" x)

  (let ((r (allow-resume x)))

    (if (procedure? r)

        (let ((y (+ x 1)))
          (printf "received continuation, calling it with ~a\n" y)
          (r y))

        (begin
          (printf "received ~a, returning it as final result\n" r)
          r))))
